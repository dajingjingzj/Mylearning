#### 1.垃圾回收：（Garbage Collection，GC）

释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

#### 2. 定义垃圾： 

##### 引用计数法：

通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。但是有一个弊端，定义2个对象，相互引用，在一段时间之后不再访问这两个对象，但是由于互相引用，所以并不能被回收。

#####  可达性分析算法：

 通过一些被称为引用链的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为引用链，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。通过可达性算法，可以解决上述引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，就会判定你为可回收对象。

#####  如何判断GCRoot：

虚拟机栈中引用的对象；

方法区中类静态属性引用的对象；

方法区中常量引用的对象；

本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。                                                

####  3.回收垃圾：

##### 标记清除算法：

它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。清理掉的垃圾就变成未使用的内存区域，等待被再次使用。弊端：会形成很多内存碎片不可用，浪费空间。

#####  复制算法：

是在标记清除算法上演变而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况。弊端：给大的内存分块，每次只使用一部分，大材小用。

#####  标记整理算法：

 标记过程标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。解决了内存碎片和复制算法只能利用一半内存区域的问题，但是，对内存频繁的移动，更新存活对象的引用地址，效率并不高。

#####  分代收集算法分代收集算法：

 对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就使用标记清理或者标记整理算法来进行回收。

#### 4. 内存区域分块：

Java 堆是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域。Java 堆主要分为2个区域-年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。

##### Eden 区：

大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。

#####  Survivor 区：

Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。

##### 为什么需要survivor区： 

如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会存活很久。这时候移入老年区，并不是一个好的行为。Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。默认保证只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。

##### 为什么需要两个survivor区：

解决内存碎片化。Survivor 如果只有一个区域会，Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。在这种情况下，只能标记清除survivor区，结果会产生严重的内存碎片。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 互换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。

#####  Old区： 

老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代采用的是标记整理算法。

###### 有几种情况对象会进入老年代：

1. 需要大量连续内存空间的大对象；
2. 长期存活的对象；
3. 如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等到虚拟机定义的15。